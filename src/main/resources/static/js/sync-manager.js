/**
 * Sync Manager for FRC Project Management System
 * Handles background synchronization of offline data with conflict resolution
 */

class SyncManager {
    constructor() {
        this.syncQueues = new Map();
        this.conflictResolvers = new Map();
        this.syncInProgress = false;
        this.syncCallbacks = new Map();
        this.retryDelays = [1000, 2000, 5000, 10000, 30000]; // Progressive backoff
        
        this.initializeSyncQueues();
        this.registerDefaultConflictResolvers();
        this.startPeriodicSync();
    }
    
    /**
     * Initialize sync queues for different data types
     */
    initializeSyncQueues() {
        const queueTypes = [
            'tasks',
            'milestones', 
            'attendance',
            'robotWeight',
            'projects',
            'teamMembers',
            'workshopSessions',
            'safetyIncidents'
        ];
        
        queueTypes.forEach(type => {
            this.syncQueues.set(type, []);
        });
    }
    
    /**
     * Register default conflict resolvers
     */
    registerDefaultConflictResolvers() {
        // Task conflict resolver - prefer most recent update
        this.conflictResolvers.set('tasks', (local, remote) => {
            const localTimestamp = new Date(local.lastModified || local.updatedAt).getTime();
            const remoteTimestamp = new Date(remote.lastModified || remote.updatedAt).getTime();
            
            if (localTimestamp > remoteTimestamp) {\n                return {\n                    resolution: 'local',\n                    data: local,\n                    reason: 'Local version is more recent'\n                };\n            } else if (remoteTimestamp > localTimestamp) {\n                return {\n                    resolution: 'remote',\n                    data: remote,\n                    reason: 'Remote version is more recent'\n                };\n            } else {\n                // Same timestamp - merge specific fields\n                return {\n                    resolution: 'merge',\n                    data: this.mergeTaskData(local, remote),\n                    reason: 'Merged complementary changes'\n                };\n            }\n        });\n        \n        // Milestone conflict resolver\n        this.conflictResolvers.set('milestones', (local, remote) => {\n            // Prefer completion status from most recent update\n            const localTime = new Date(local.lastModified || local.updatedAt).getTime();\n            const remoteTime = new Date(remote.lastModified || remote.updatedAt).getTime();\n            \n            if (Math.abs(localTime - remoteTime) < 5000) { // Within 5 seconds\n                return {\n                    resolution: 'merge',\n                    data: {\n                        ...remote,\n                        completionPercentage: Math.max(local.completionPercentage, remote.completionPercentage),\n                        completed: local.completed || remote.completed,\n                        completionDate: local.completionDate || remote.completionDate\n                    },\n                    reason: 'Merged progress updates'\n                };\n            }\n            \n            return localTime > remoteTime ? \n                { resolution: 'local', data: local, reason: 'Local is more recent' } :\n                { resolution: 'remote', data: remote, reason: 'Remote is more recent' };\n        });\n        \n        // Attendance conflict resolver - prefer check-in over check-out\n        this.conflictResolvers.set('attendance', (local, remote) => {\n            if (local.action === 'CHECK_IN' && remote.action === 'CHECK_OUT') {\n                return {\n                    resolution: 'local',\n                    data: local,\n                    reason: 'Prefer check-in over check-out'\n                };\n            } else if (local.action === 'CHECK_OUT' && remote.action === 'CHECK_IN') {\n                return {\n                    resolution: 'remote',\n                    data: remote,\n                    reason: 'Prefer check-in over check-out'\n                };\n            }\n            \n            // Same action - prefer most recent\n            const localTime = new Date(local.timestamp).getTime();\n            const remoteTime = new Date(remote.timestamp).getTime();\n            \n            return localTime > remoteTime ?\n                { resolution: 'local', data: local, reason: 'Local is more recent' } :\n                { resolution: 'remote', data: remote, reason: 'Remote is more recent' };\n        });\n        \n        // Robot weight conflict resolver - prefer most recent measurement\n        this.conflictResolvers.set('robotWeight', (local, remote) => {\n            const localTime = new Date(local.measuredAt).getTime();\n            const remoteTime = new Date(remote.measuredAt).getTime();\n            \n            return localTime > remoteTime ?\n                { resolution: 'local', data: local, reason: 'Local measurement is more recent' } :\n                { resolution: 'remote', data: remote, reason: 'Remote measurement is more recent' };\n        });\n    }\n    \n    /**\n     * Queue an item for synchronization\n     */\n    async queueForSync(type, operation, data, options = {}) {\n        const queueItem = {\n            id: this.generateSyncId(),\n            type,\n            operation, // 'create', 'update', 'delete'\n            data,\n            url: options.url,\n            method: options.method || 'POST',\n            headers: options.headers || {},\n            timestamp: Date.now(),\n            retryCount: 0,\n            priority: options.priority || 'normal', // 'high', 'normal', 'low'\n            batchable: options.batchable !== false,\n            ...options\n        };\n        \n        const queue = this.syncQueues.get(type);\n        if (!queue) {\n            throw new Error(`Unknown sync queue type: ${type}`);\n        }\n        \n        // Insert based on priority\n        if (queueItem.priority === 'high') {\n            queue.unshift(queueItem);\n        } else {\n            queue.push(queueItem);\n        }\n        \n        // Persist to IndexedDB\n        await this.persistSyncQueue(type, queue);\n        \n        console.log(`SyncManager: Queued ${type} ${operation}`, queueItem.id);\n        \n        // Trigger immediate sync if high priority and online\n        if (queueItem.priority === 'high' && navigator.onLine) {\n            this.syncType(type);\n        }\n        \n        return queueItem.id;\n    }\n    \n    /**\n     * Sync all queued items\n     */\n    async syncAll() {\n        if (this.syncInProgress) {\n            console.log('SyncManager: Sync already in progress');\n            return;\n        }\n        \n        if (!navigator.onLine) {\n            console.log('SyncManager: Device is offline, skipping sync');\n            return;\n        }\n        \n        this.syncInProgress = true;\n        \n        try {\n            console.log('SyncManager: Starting full sync');\n            \n            // Sync high priority items first\n            for (const [type, queue] of this.syncQueues) {\n                const highPriorityItems = queue.filter(item => item.priority === 'high');\n                if (highPriorityItems.length > 0) {\n                    await this.syncType(type, highPriorityItems);\n                }\n            }\n            \n            // Then sync normal and low priority items\n            for (const [type, queue] of this.syncQueues) {\n                const normalItems = queue.filter(item => item.priority !== 'high');\n                if (normalItems.length > 0) {\n                    await this.syncType(type, normalItems);\n                }\n            }\n            \n            console.log('SyncManager: Full sync completed');\n        } catch (error) {\n            console.error('SyncManager: Error during sync', error);\n        } finally {\n            this.syncInProgress = false;\n        }\n    }\n    \n    /**\n     * Sync specific type of data\n     */\n    async syncType(type, items = null) {\n        const queue = this.syncQueues.get(type);\n        if (!queue || queue.length === 0) {\n            return;\n        }\n        \n        const itemsToSync = items || queue.slice();\n        console.log(`SyncManager: Syncing ${type}`, itemsToSync.length, 'items');\n        \n        const results = {\n            success: 0,\n            failed: 0,\n            conflicts: 0\n        };\n        \n        // Group batchable items\n        const batches = this.groupIntoBatches(itemsToSync);\n        \n        for (const batch of batches) {\n            if (batch.length === 1) {\n                const result = await this.syncSingleItem(batch[0]);\n                results[result.status]++;\n            } else {\n                const result = await this.syncBatch(type, batch);\n                results.success += result.success;\n                results.failed += result.failed;\n                results.conflicts += result.conflicts;\n            }\n        }\n        \n        console.log(`SyncManager: ${type} sync completed`, results);\n        \n        // Remove successfully synced items from queue\n        await this.cleanupSyncQueue(type);\n        \n        // Trigger callbacks\n        this.triggerSyncCallbacks(type, results);\n    }\n    \n    /**\n     * Sync a single item\n     */\n    async syncSingleItem(item) {\n        try {\n            const response = await fetch(item.url || this.buildSyncUrl(item), {\n                method: item.method,\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Requested-With': 'XMLHttpRequest',\n                    ...item.headers\n                },\n                body: item.data ? JSON.stringify(item.data) : undefined\n            });\n            \n            if (response.ok) {\n                const responseData = await response.json();\n                \n                // Check for conflicts\n                if (responseData.conflict) {\n                    const resolution = await this.resolveConflict(item.type, item.data, responseData.remoteData);\n                    if (resolution.resolution === 'local') {\n                        // Retry with force flag\n                        return await this.syncSingleItem({\n                            ...item,\n                            headers: { ...item.headers, 'X-Force-Update': 'true' }\n                        });\n                    }\n                    return { status: 'conflicts', item, resolution };\n                }\n                \n                item.synced = true;\n                item.syncedAt = Date.now();\n                return { status: 'success', item, response: responseData };\n            } else {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n        } catch (error) {\n            console.error('SyncManager: Error syncing item', item.id, error);\n            \n            item.retryCount++;\n            item.lastError = error.message;\n            item.nextRetryAt = Date.now() + this.getRetryDelay(item.retryCount);\n            \n            return { status: 'failed', item, error };\n        }\n    }\n    \n    /**\n     * Sync a batch of items\n     */\n    async syncBatch(type, batch) {\n        const batchData = batch.map(item => item.data);\n        \n        try {\n            const response = await fetch(this.buildBatchSyncUrl(type), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Requested-With': 'XMLHttpRequest'\n                },\n                body: JSON.stringify({ items: batchData })\n            });\n            \n            if (response.ok) {\n                const responseData = await response.json();\n                \n                // Mark all items as synced\n                batch.forEach(item => {\n                    item.synced = true;\n                    item.syncedAt = Date.now();\n                });\n                \n                return {\n                    success: batch.length,\n                    failed: 0,\n                    conflicts: 0\n                };\n            } else {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n        } catch (error) {\n            console.error('SyncManager: Error syncing batch', type, error);\n            \n            // Mark all items as failed\n            batch.forEach(item => {\n                item.retryCount++;\n                item.lastError = error.message;\n                item.nextRetryAt = Date.now() + this.getRetryDelay(item.retryCount);\n            });\n            \n            return {\n                success: 0,\n                failed: batch.length,\n                conflicts: 0\n            };\n        }\n    }\n    \n    /**\n     * Group items into batches\n     */\n    groupIntoBatches(items) {\n        const batches = [];\n        let currentBatch = [];\n        \n        for (const item of items) {\n            if (item.batchable && currentBatch.length < 10) {\n                currentBatch.push(item);\n            } else {\n                if (currentBatch.length > 0) {\n                    batches.push(currentBatch);\n                    currentBatch = [];\n                }\n                \n                if (item.batchable) {\n                    currentBatch.push(item);\n                } else {\n                    batches.push([item]);\n                }\n            }\n        }\n        \n        if (currentBatch.length > 0) {\n            batches.push(currentBatch);\n        }\n        \n        return batches;\n    }\n    \n    /**\n     * Resolve conflicts between local and remote data\n     */\n    async resolveConflict(type, localData, remoteData) {\n        const resolver = this.conflictResolvers.get(type);\n        \n        if (!resolver) {\n            // Default resolution - prefer remote\n            return {\n                resolution: 'remote',\n                data: remoteData,\n                reason: 'No conflict resolver available, using remote data'\n            };\n        }\n        \n        const resolution = resolver(localData, remoteData);\n        \n        console.log(`SyncManager: Conflict resolved for ${type}`, resolution);\n        \n        // Store conflict resolution for audit\n        await this.storeConflictResolution(type, localData, remoteData, resolution);\n        \n        return resolution;\n    }\n    \n    /**\n     * Merge task data intelligently\n     */\n    mergeTaskData(local, remote) {\n        return {\n            ...remote,\n            // Preserve local progress if higher\n            progress: Math.max(local.progress || 0, remote.progress || 0),\n            // Merge notes\n            notes: this.mergeNotes(local.notes, remote.notes),\n            // Preserve completion status if local is completed\n            completed: local.completed || remote.completed,\n            // Use most recent timestamps\n            startDate: local.startDate || remote.startDate,\n            endDate: local.endDate || remote.endDate,\n            // Merge assigned members\n            assignedTo: this.mergeAssignments(local.assignedTo, remote.assignedTo)\n        };\n    }\n    \n    /**\n     * Merge notes from local and remote\n     */\n    mergeNotes(localNotes, remoteNotes) {\n        if (!localNotes && !remoteNotes) return null;\n        if (!localNotes) return remoteNotes;\n        if (!remoteNotes) return localNotes;\n        \n        // If notes are different, append with timestamp\n        if (localNotes !== remoteNotes) {\n            return `${remoteNotes}\\n\\n[Local update]: ${localNotes}`;\n        }\n        \n        return remoteNotes;\n    }\n    \n    /**\n     * Merge assignments from local and remote\n     */\n    mergeAssignments(localAssignments, remoteAssignments) {\n        if (!localAssignments && !remoteAssignments) return null;\n        if (!localAssignments) return remoteAssignments;\n        if (!remoteAssignments) return localAssignments;\n        \n        // Merge unique assignments\n        const merged = [...remoteAssignments];\n        localAssignments.forEach(local => {\n            if (!merged.find(remote => remote.id === local.id)) {\n                merged.push(local);\n            }\n        });\n        \n        return merged;\n    }\n    \n    /**\n     * Build sync URL for single item\n     */\n    buildSyncUrl(item) {\n        const baseUrl = '/api/sync';\n        return `${baseUrl}/${item.type}/${item.operation}`;\n    }\n    \n    /**\n     * Build batch sync URL\n     */\n    buildBatchSyncUrl(type) {\n        return `/api/sync/${type}/batch`;\n    }\n    \n    /**\n     * Get retry delay with exponential backoff\n     */\n    getRetryDelay(retryCount) {\n        const index = Math.min(retryCount - 1, this.retryDelays.length - 1);\n        return this.retryDelays[index];\n    }\n    \n    /**\n     * Clean up synced items from queue\n     */\n    async cleanupSyncQueue(type) {\n        const queue = this.syncQueues.get(type);\n        const itemsToKeep = queue.filter(item => {\n            // Keep items that failed but haven't exceeded retry limit\n            if (!item.synced && item.retryCount < 5) {\n                return Date.now() >= (item.nextRetryAt || 0);\n            }\n            return false;\n        });\n        \n        this.syncQueues.set(type, itemsToKeep);\n        await this.persistSyncQueue(type, itemsToKeep);\n    }\n    \n    /**\n     * Persist sync queue to IndexedDB\n     */\n    async persistSyncQueue(type, queue) {\n        if (window.offlineManager) {\n            await window.offlineManager.storeInIndexedDB(`syncQueue_${type}`, queue);\n        }\n    }\n    \n    /**\n     * Load sync queues from IndexedDB\n     */\n    async loadSyncQueues() {\n        if (!window.offlineManager) return;\n        \n        for (const [type] of this.syncQueues) {\n            try {\n                const queue = await window.offlineManager.getFromIndexedDB(`syncQueue_${type}`);\n                if (queue) {\n                    this.syncQueues.set(type, queue);\n                }\n            } catch (error) {\n                console.error(`SyncManager: Error loading ${type} queue`, error);\n            }\n        }\n    }\n    \n    /**\n     * Store conflict resolution for audit\n     */\n    async storeConflictResolution(type, localData, remoteData, resolution) {\n        const conflictRecord = {\n            id: this.generateSyncId(),\n            type,\n            localData,\n            remoteData,\n            resolution,\n            timestamp: Date.now()\n        };\n        \n        if (window.offlineManager) {\n            await window.offlineManager.storeInIndexedDB('conflictResolutions', conflictRecord);\n        }\n    }\n    \n    /**\n     * Register sync callback\n     */\n    onSyncComplete(type, callback) {\n        const callbacks = this.syncCallbacks.get(type) || [];\n        callbacks.push(callback);\n        this.syncCallbacks.set(type, callbacks);\n    }\n    \n    /**\n     * Trigger sync callbacks\n     */\n    triggerSyncCallbacks(type, results) {\n        const callbacks = this.syncCallbacks.get(type) || [];\n        callbacks.forEach(callback => {\n            try {\n                callback(results);\n            } catch (error) {\n                console.error('SyncManager: Error in sync callback', error);\n            }\n        });\n    }\n    \n    /**\n     * Get sync queue status\n     */\n    getQueueStatus() {\n        const status = {};\n        \n        for (const [type, queue] of this.syncQueues) {\n            status[type] = {\n                total: queue.length,\n                pending: queue.filter(item => !item.synced).length,\n                failed: queue.filter(item => item.retryCount > 0).length,\n                highPriority: queue.filter(item => item.priority === 'high').length\n            };\n        }\n        \n        return status;\n    }\n    \n    /**\n     * Clear all sync queues\n     */\n    async clearAllQueues() {\n        for (const [type] of this.syncQueues) {\n            this.syncQueues.set(type, []);\n            await this.persistSyncQueue(type, []);\n        }\n        \n        console.log('SyncManager: All queues cleared');\n    }\n    \n    /**\n     * Start periodic sync\n     */\n    startPeriodicSync() {\n        // Sync every 5 minutes\n        setInterval(() => {\n            if (navigator.onLine && !this.syncInProgress) {\n                this.syncAll();\n            }\n        }, 5 * 60 * 1000);\n        \n        // Sync when coming back online\n        window.addEventListener('online', () => {\n            setTimeout(() => this.syncAll(), 1000);\n        });\n    }\n    \n    /**\n     * Generate unique sync ID\n     */\n    generateSyncId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    \n    /**\n     * Register custom conflict resolver\n     */\n    registerConflictResolver(type, resolver) {\n        this.conflictResolvers.set(type, resolver);\n    }\n    \n    /**\n     * Force sync of specific item\n     */\n    async forceSyncItem(type, itemId) {\n        const queue = this.syncQueues.get(type);\n        if (!queue) return false;\n        \n        const item = queue.find(i => i.id === itemId);\n        if (!item) return false;\n        \n        item.priority = 'high';\n        item.headers = { ...item.headers, 'X-Force-Update': 'true' };\n        \n        const result = await this.syncSingleItem(item);\n        return result.status === 'success';\n    }\n}\n\n// Initialize sync manager\nlet syncManager;\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    syncManager = new SyncManager();\n    \n    // Load existing queues\n    syncManager.loadSyncQueues();\n    \n    // Make globally available\n    window.syncManager = syncManager;\n    \n    console.log('SyncManager: Initialized and ready');\n});\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = SyncManager;\n}