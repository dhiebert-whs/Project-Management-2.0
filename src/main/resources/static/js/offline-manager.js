/**
 * Offline Manager for FRC Project Management System
 * Handles offline state detection, UI updates, and data synchronization
 */

class OfflineManager {
    constructor() {
        this.isOnline = navigator.onLine;
        this.onlineListeners = [];
        this.offlineListeners = [];
        this.syncQueue = [];
        this.pendingOperations = new Map();
        
        this.initializeEventListeners();
        this.initializeUI();
        this.initializeIndexedDB();
        this.startPeriodicSync();
    }
    
    /**
     * Initialize event listeners for online/offline state changes
     */
    initializeEventListeners() {
        window.addEventListener('online', () => {
            console.log('OfflineManager: Device is now online');
            this.isOnline = true;
            this.handleOnlineEvent();
        });
        
        window.addEventListener('offline', () => {
            console.log('OfflineManager: Device is now offline');
            this.isOnline = false;
            this.handleOfflineEvent();
        });
        
        // Listen for visibility changes to sync when app becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && this.isOnline) {
                this.syncPendingOperations();
            }
        });
    }
    
    /**
     * Initialize UI components for offline status
     */
    initializeUI() {
        this.createOfflineIndicator();
        this.updateConnectionStatus();
    }
    
    /**
     * Initialize IndexedDB for offline data storage
     */
    async initializeIndexedDB() {
        try {
            this.db = await this.openDatabase();
            console.log('OfflineManager: IndexedDB initialized');
        } catch (error) {
            console.error('OfflineManager: Failed to initialize IndexedDB', error);
        }
    }
    
    /**
     * Open IndexedDB database
     */
    openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('FRCProjectManagement', 1);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                // Create object stores for different data types
                if (!db.objectStoreNames.contains('tasks')) {\n                    const taskStore = db.createObjectStore('tasks', { keyPath: 'id' });\n                    taskStore.createIndex('project', 'projectId', { unique: false });\n                    taskStore.createIndex('assignee', 'assigneeId', { unique: false });\n                    taskStore.createIndex('lastModified', 'lastModified', { unique: false });\n                }\n                \n                if (!db.objectStoreNames.contains('milestones')) {\n                    const milestoneStore = db.createObjectStore('milestones', { keyPath: 'id' });\n                    milestoneStore.createIndex('project', 'projectId', { unique: false });\n                    milestoneStore.createIndex('targetDate', 'targetDate', { unique: false });\n                }\n                \n                if (!db.objectStoreNames.contains('attendance')) {\n                    const attendanceStore = db.createObjectStore('attendance', { keyPath: 'id' });\n                    attendanceStore.createIndex('session', 'sessionId', { unique: false });\n                    attendanceStore.createIndex('member', 'memberId', { unique: false });\n                    attendanceStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n                \n                if (!db.objectStoreNames.contains('syncQueue')) {\n                    const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id', autoIncrement: true });\n                    syncStore.createIndex('type', 'type', { unique: false });\n                    syncStore.createIndex('timestamp', 'timestamp', { unique: false });\n                }\n                \n                if (!db.objectStoreNames.contains('projects')) {\n                    const projectStore = db.createObjectStore('projects', { keyPath: 'id' });\n                    projectStore.createIndex('name', 'name', { unique: false });\n                    projectStore.createIndex('status', 'status', { unique: false });\n                }\n                \n                if (!db.objectStoreNames.contains('teamMembers')) {\n                    const memberStore = db.createObjectStore('teamMembers', { keyPath: 'id' });\n                    memberStore.createIndex('name', 'fullName', { unique: false });\n                    memberStore.createIndex('role', 'role', { unique: false });\n                }\n            };\n        });\n    }\n    \n    /**\n     * Create offline indicator in the UI\n     */\n    createOfflineIndicator() {\n        const indicator = document.createElement('div');\n        indicator.id = 'offline-indicator';\n        indicator.className = 'offline-indicator';\n        indicator.innerHTML = `\n            <div class=\"offline-content\">\n                <i class=\"fas fa-wifi-slash\"></i>\n                <span id=\"offline-message\">You are offline</span>\n            </div>\n        `;\n        \n        // Add CSS if not already present\n        if (!document.querySelector('#offline-indicator-styles')) {\n            const style = document.createElement('style');\n            style.id = 'offline-indicator-styles';\n            style.textContent = `\n                .offline-indicator {\n                    position: fixed;\n                    top: 0;\n                    left: 0;\n                    right: 0;\n                    background: linear-gradient(135deg, #dc3545, #c82333);\n                    color: white;\n                    padding: 0.75rem;\n                    text-align: center;\n                    font-weight: 600;\n                    z-index: 9999;\n                    transform: translateY(-100%);\n                    transition: transform 0.3s ease;\n                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);\n                }\n                \n                .offline-indicator.show {\n                    transform: translateY(0);\n                }\n                \n                .offline-indicator.online {\n                    background: linear-gradient(135deg, #28a745, #20c997);\n                }\n                \n                .offline-content {\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    gap: 0.5rem;\n                }\n                \n                .sync-indicator {\n                    display: inline-flex;\n                    align-items: center;\n                    gap: 0.25rem;\n                    margin-left: 1rem;\n                    font-size: 0.9rem;\n                }\n                \n                .sync-spinner {\n                    width: 12px;\n                    height: 12px;\n                    border: 2px solid rgba(255,255,255,0.3);\n                    border-top: 2px solid white;\n                    border-radius: 50%;\n                    animation: spin 1s linear infinite;\n                }\n                \n                @keyframes spin {\n                    0% { transform: rotate(0deg); }\n                    100% { transform: rotate(360deg); }\n                }\n            `;\n            document.head.appendChild(style);\n        }\n        \n        document.body.appendChild(indicator);\n        this.offlineIndicator = indicator;\n    }\n    \n    /**\n     * Update connection status in UI\n     */\n    updateConnectionStatus() {\n        const indicator = this.offlineIndicator;\n        const message = document.getElementById('offline-message');\n        \n        if (this.isOnline) {\n            indicator.classList.add('online');\n            indicator.classList.remove('show');\n            message.innerHTML = '<i class=\"fas fa-wifi\"></i> Back online';\n            \n            // Hide after 3 seconds\n            setTimeout(() => {\n                indicator.classList.remove('show');\n            }, 3000);\n        } else {\n            indicator.classList.remove('online');\n            indicator.classList.add('show');\n            message.innerHTML = '<i class=\"fas fa-wifi-slash\"></i> You are offline';\n            \n            // Show pending operations count if any\n            const pendingCount = this.syncQueue.length;\n            if (pendingCount > 0) {\n                message.innerHTML += ` â€¢ ${pendingCount} pending updates`;\n            }\n        }\n    }\n    \n    /**\n     * Handle online event\n     */\n    handleOnlineEvent() {\n        this.updateConnectionStatus();\n        this.syncPendingOperations();\n        this.onlineListeners.forEach(listener => listener());\n    }\n    \n    /**\n     * Handle offline event\n     */\n    handleOfflineEvent() {\n        this.updateConnectionStatus();\n        this.offlineListeners.forEach(listener => listener());\n    }\n    \n    /**\n     * Register listener for online events\n     */\n    onOnline(callback) {\n        this.onlineListeners.push(callback);\n    }\n    \n    /**\n     * Register listener for offline events\n     */\n    onOffline(callback) {\n        this.offlineListeners.push(callback);\n    }\n    \n    /**\n     * Check if device is online\n     */\n    isDeviceOnline() {\n        return this.isOnline;\n    }\n    \n    /**\n     * Queue operation for sync when online\n     */\n    async queueOperation(operation) {\n        const operationId = this.generateOperationId();\n        const queueItem = {\n            id: operationId,\n            ...operation,\n            timestamp: Date.now(),\n            retryCount: 0\n        };\n        \n        // Add to sync queue\n        this.syncQueue.push(queueItem);\n        \n        // Store in IndexedDB for persistence\n        await this.storeInIndexedDB('syncQueue', queueItem);\n        \n        // Update UI\n        this.updateConnectionStatus();\n        \n        // Try to sync immediately if online\n        if (this.isOnline) {\n            this.syncPendingOperations();\n        }\n        \n        return operationId;\n    }\n    \n    /**\n     * Sync pending operations when online\n     */\n    async syncPendingOperations() {\n        if (!this.isOnline || this.syncQueue.length === 0) {\n            return;\n        }\n        \n        console.log('OfflineManager: Syncing pending operations', this.syncQueue.length);\n        \n        this.showSyncIndicator();\n        \n        const operations = [...this.syncQueue];\n        let syncedCount = 0;\n        \n        for (const operation of operations) {\n            try {\n                const success = await this.syncOperation(operation);\n                if (success) {\n                    await this.removeFromSyncQueue(operation.id);\n                    syncedCount++;\n                } else {\n                    // Increment retry count\n                    operation.retryCount++;\n                    if (operation.retryCount >= 3) {\n                        console.error('OfflineManager: Max retries reached for operation', operation.id);\n                        await this.removeFromSyncQueue(operation.id);\n                    }\n                }\n            } catch (error) {\n                console.error('OfflineManager: Error syncing operation', operation.id, error);\n                operation.retryCount++;\n            }\n        }\n        \n        this.hideSyncIndicator();\n        \n        if (syncedCount > 0) {\n            this.showSyncSuccessMessage(syncedCount);\n        }\n    }\n    \n    /**\n     * Sync individual operation\n     */\n    async syncOperation(operation) {\n        try {\n            const response = await fetch(operation.url, {\n                method: operation.method || 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Requested-With': 'XMLHttpRequest',\n                    ...operation.headers\n                },\n                body: operation.data ? JSON.stringify(operation.data) : undefined\n            });\n            \n            if (response.ok) {\n                console.log('OfflineManager: Operation synced successfully', operation.id);\n                return true;\n            } else {\n                console.error('OfflineManager: Operation sync failed', operation.id, response.status);\n                return false;\n            }\n        } catch (error) {\n            console.error('OfflineManager: Network error during sync', operation.id, error);\n            return false;\n        }\n    }\n    \n    /**\n     * Remove operation from sync queue\n     */\n    async removeFromSyncQueue(operationId) {\n        this.syncQueue = this.syncQueue.filter(op => op.id !== operationId);\n        await this.removeFromIndexedDB('syncQueue', operationId);\n        this.updateConnectionStatus();\n    }\n    \n    /**\n     * Show sync indicator\n     */\n    showSyncIndicator() {\n        const message = document.getElementById('offline-message');\n        const indicator = this.offlineIndicator;\n        \n        if (this.isOnline) {\n            indicator.classList.add('online', 'show');\n            message.innerHTML = `\n                <i class=\"fas fa-sync-alt fa-spin\"></i>\n                Syncing updates...\n            `;\n        }\n    }\n    \n    /**\n     * Hide sync indicator\n     */\n    hideSyncIndicator() {\n        if (this.isOnline) {\n            setTimeout(() => {\n                this.offlineIndicator.classList.remove('show');\n            }, 1000);\n        }\n    }\n    \n    /**\n     * Show sync success message\n     */\n    showSyncSuccessMessage(count) {\n        const message = document.getElementById('offline-message');\n        const indicator = this.offlineIndicator;\n        \n        indicator.classList.add('online', 'show');\n        message.innerHTML = `\n            <i class=\"fas fa-check-circle\"></i>\n            ${count} updates synced successfully\n        `;\n        \n        setTimeout(() => {\n            indicator.classList.remove('show');\n        }, 3000);\n    }\n    \n    /**\n     * Store data in IndexedDB\n     */\n    async storeInIndexedDB(storeName, data) {\n        if (!this.db) return;\n        \n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([storeName], 'readwrite');\n            const store = transaction.objectStore(storeName);\n            const request = store.put(data);\n            \n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    /**\n     * Get data from IndexedDB\n     */\n    async getFromIndexedDB(storeName, key) {\n        if (!this.db) return null;\n        \n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([storeName], 'readonly');\n            const store = transaction.objectStore(storeName);\n            const request = key ? store.get(key) : store.getAll();\n            \n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    /**\n     * Remove data from IndexedDB\n     */\n    async removeFromIndexedDB(storeName, key) {\n        if (!this.db) return;\n        \n        return new Promise((resolve, reject) => {\n            const transaction = this.db.transaction([storeName], 'readwrite');\n            const store = transaction.objectStore(storeName);\n            const request = store.delete(key);\n            \n            request.onsuccess = () => resolve();\n            request.onerror = () => reject(request.error);\n        });\n    }\n    \n    /**\n     * Cache data for offline use\n     */\n    async cacheData(storeName, data) {\n        if (Array.isArray(data)) {\n            for (const item of data) {\n                await this.storeInIndexedDB(storeName, {\n                    ...item,\n                    lastModified: Date.now(),\n                    cached: true\n                });\n            }\n        } else {\n            await this.storeInIndexedDB(storeName, {\n                ...data,\n                lastModified: Date.now(),\n                cached: true\n            });\n        }\n    }\n    \n    /**\n     * Get cached data\n     */\n    async getCachedData(storeName, key) {\n        const data = await this.getFromIndexedDB(storeName, key);\n        return data;\n    }\n    \n    /**\n     * Start periodic sync attempts\n     */\n    startPeriodicSync() {\n        setInterval(() => {\n            if (this.isOnline && this.syncQueue.length > 0) {\n                this.syncPendingOperations();\n            }\n        }, 30000); // Try every 30 seconds\n    }\n    \n    /**\n     * Generate unique operation ID\n     */\n    generateOperationId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n    \n    /**\n     * Load pending operations from IndexedDB on startup\n     */\n    async loadPendingOperations() {\n        try {\n            const pendingOps = await this.getFromIndexedDB('syncQueue');\n            this.syncQueue = pendingOps || [];\n            console.log('OfflineManager: Loaded pending operations', this.syncQueue.length);\n        } catch (error) {\n            console.error('OfflineManager: Failed to load pending operations', error);\n        }\n    }\n    \n    /**\n     * Clear all offline data\n     */\n    async clearOfflineData() {\n        if (!this.db) return;\n        \n        const storeNames = ['tasks', 'milestones', 'attendance', 'syncQueue', 'projects', 'teamMembers'];\n        \n        for (const storeName of storeNames) {\n            try {\n                const transaction = this.db.transaction([storeName], 'readwrite');\n                const store = transaction.objectStore(storeName);\n                await store.clear();\n                console.log('OfflineManager: Cleared store', storeName);\n            } catch (error) {\n                console.error('OfflineManager: Error clearing store', storeName, error);\n            }\n        }\n        \n        this.syncQueue = [];\n        this.updateConnectionStatus();\n    }\n    \n    /**\n     * Get offline data statistics\n     */\n    async getOfflineStats() {\n        const stats = {\n            pendingOperations: this.syncQueue.length,\n            cachedTasks: 0,\n            cachedMilestones: 0,\n            cachedAttendance: 0,\n            cachedProjects: 0,\n            cachedMembers: 0\n        };\n        \n        try {\n            const storeNames = ['tasks', 'milestones', 'attendance', 'projects', 'teamMembers'];\n            for (const storeName of storeNames) {\n                const data = await this.getFromIndexedDB(storeName);\n                stats[`cached${storeName.charAt(0).toUpperCase() + storeName.slice(1)}`] = data ? data.length : 0;\n            }\n        } catch (error) {\n            console.error('OfflineManager: Error getting offline stats', error);\n        }\n        \n        return stats;\n    }\n}\n\n// Initialize offline manager when DOM is ready\nlet offlineManager;\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    offlineManager = new OfflineManager();\n    \n    // Load pending operations\n    offlineManager.loadPendingOperations();\n    \n    // Make globally available\n    window.offlineManager = offlineManager;\n    \n    console.log('OfflineManager: Initialized and ready');\n});\n\n// Export for use in other modules\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = OfflineManager;\n}